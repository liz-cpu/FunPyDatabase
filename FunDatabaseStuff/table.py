from sqlite3.dbapi2 import Cursor
from FunDatabaseStuff.exceptions import (
    CreateNonExistent,
    ColumnError,
    InvalidCreate
)
from FunDatabaseStuff.types import (
    Value,
    ColValueUpdateList
)


class TableCreate(object):
    """Class representation of a SQL-CREATE TABLE script used by
    :class:`FunDatabaseStuff.Table`

    :param name: Name of the table that would be generated by this create
    :type name: str
    :param create: String that contains a SQL-CREATE TABLE script.
    :type create: str
    """

    def __init__(self, name: str, create: str) -> None:
        """Constructor method
        """
        self.name = name
        self.create = self.check_create(create)

    def __repr__(self) -> str:
        return self.create

    def check_create(self, create: str) -> str:
        """Checks the validity of a create string

        :param create: String that contains a SQL-CREATE TABLE script.
        :type create: str
        :raises InvalidCreate: Supplied create is invalid.
        :return: :param create:
        :rtype: str
        """
        datatypes = ("INT", "CHAR", "TEXT", "BLOB", "REAL", "FLOAT",
                     "NUMERIC", "DECIMAL", "BOOLEAN", "DATE")
        create = create.strip()
        if create.startswith(f'CREATE TABLE IF NOT EXISTS {self.name} (') \
                or create.startswith(f'CREATE TABLE {self.name} ('):
            if create.endswith(';'):
                if "PRIMARY KEY" in create:
                    for type in datatypes:
                        if type in create:
                            return create
        raise InvalidCreate('Create table is invalid')


class Table(object):
    """Class representation of a Table in a SQLite3 database.

    :param name: Name of the table
    :type name: str
    :param create: Create script fot the table, should it not
        exist yet or be deleted, defaults to None
    :type create: TableCreate, optional
    :param *cols: All columns inside the table
    :type cols: str
    """

    def __init__(self, name: str, *cols: str, create: TableCreate = None) -> None:
        """Constructor method
        """
        self.name = name
        self.columns = list(cols)
        self.create = create
        self.has_create = True if create else False

    def __repr__(self) -> str:
        cols = ", ".join(self.columns)
        if self.__create:
            return f'Table({self.name}, {self.__create}, {cols})'
        else:
            return f'Table({self.name},  {cols})'

    def __str__(self) -> str:
        cols = ", ".join(self.columns)
        return f'Table {self.name} with columns {cols}.'

    def add_create(self, create: TableCreate) -> None:
        self.create = create

    def create(self, db: Cursor) -> None:
        """Creates a table (if not exists) in the SQLite3 Database

        :param db: The database cursor
        :type db: Cursor
        :raises CreateNonExistent: No create is registred with the database,
        thus is unable to be created
        """
        if self.__create:
            db.execute(str(self.__create))
        else:
            raise CreateNonExistent('No create registered for this table')

    def select(self, db: Cursor, *cols: str, **where: Value) -> tuple:
        """Basic SELECT function.

        TODO: Add JOIN support

        :param db: The database cursor
        :type db: Cursor
        :param *cols: columns to be selected
        :type *cols: str
        :param **where: WHERE-part of the query
        :type **where: Value == int | str | float
        :return: tuple of all rows
        :rtype: tuple
        """
        name = self.name
        if not where and not cols:
            db.execute(f'SELECT * FROM {name}')

        elif cols and not where:
            colpld = '(' + ", ".join(tuple('?' for _ in cols)) + ')'
            pldv = cols
            db.execute(f'SELECT {colpld} FROM {name}', pldv)
        elif where and not cols:
            pldv = [[column, value] for column, value in where.items()]
            where_plhd = '(' + ", ".join(tuple('? = ?' for _ in cols)) + ')'
            db.execute(f'SELECT * FROM {name} WHERE {where_plhd}', pldv)

        else:
            colpld = '(' + ", ".join(tuple('?' for _ in cols)) + ')'
            where_list = [[column, value] for column, value in where.items()]
            where_plhd = '(' + " AND ".join(tuple('? = ?' for _ in cols)) + ')'
            pldv = cols
            pldv.extend(where_list)

            db.execute(
                f'SELECT {colpld} FROM {name} WHERE {where_plhd}', pldv)

        return tuple(row for row in db)

    def insert(self, db: Cursor, *values: Value) -> None:
        """Basic INSERT function

        TODO: make it able to leave some columns out of INSERT

        :param db: The database cursor
        :type db: Cursor
        :param *values: Values to be inserted
        :type *values: Value == int | str | float
        :raises ColumnError: Amount of values given does not match
        amount of columns registered
        """
        if len(values) != len(self.columns):
            raise ColumnError(
                'Amount of values does not match amount of columns.')
        placeholders = '(' + ", ".join(tuple('?' for _ in values)) + ')'
        db.execute(f'INSERT INTO {self.name} VALUES {placeholders}', values)

    @staticmethod
    def create_query(x: list, sep: str) -> str:
        # TODO: Remove this and all references to this function
        L = []
        for col, value in x:
            if isinstance(value, str):
                value = f'\"{value}\"'
            L += [f'{col} = {value}']
        if len(L) > 1:
            return f" {sep} ".join(L)
        else:
            return str(L[0])

    def update(self, db: Cursor, *vals: ColValueUpdateList) -> None:
        """Basic UPDATE function

        :param db: The database cursor
        :type db: Cursor
        :param *vals: Values to use for search/updating
        :type: *vals: ColValueUpdateList
        :raises CreateNonExistent: CREATE TABLE not given to table object
        """
        name = self.name
        replace_list = []
        search_list = []
        for col_o_n in vals:
            if col_o_n[0] not in self.columns:
                raise CreateNonExistent(
                    f'Column {col_o_n[0]} does not exist')

            if not isinstance(col_o_n, tuple):
                raise TypeError('vals arguments should be tuple.')

            if not isinstance(col_o_n[0], str) or 1 <= len(col_o_n) > 3:
                raise TypeError("Function call is incorrect, should be `name, \
                current_value, new_value (optional)`.")

            if len(col_o_n) == 3:
                replace_list.append([col_o_n[0], col_o_n[2]])
                search_list.append(col_o_n[:2])
            else:
                search_list.append(col_o_n)

        if not replace_list:
            raise TypeError("Update should at least have 1 column to update.")
        else:
            updates = self.create_query(replace_list, ',')
            search_query = self.create_query(search_list, 'AND')
            db.execute(f'UPDATE {name} SET {updates} WHERE {search_query}')
